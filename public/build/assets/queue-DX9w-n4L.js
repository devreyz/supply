class b{constructor(t="spa_app",e=1){this.dbName=t,this.version=e,this.db=null,this._stores=new Map,this._migrations=[],this._observers=new Map,this._pendingUpgrade=null}observe(t,e){return this._observers.has(t)||this._observers.set(t,new Set),this._observers.get(t).add(e),()=>this._observers.get(t).delete(e)}_notify(t,e,s){this._observers.has(t)&&this._observers.get(t).forEach(o=>{try{o({table:t,type:e,data:s,timestamp:new Date})}catch(r){console.error(`Erro no observer de ${t}:`,r)}})}async defineTable(t,e={}){this._stores.set(t,{keyPath:e.keyPath||"id",autoIncrement:e.autoIncrement!==!1,indexes:e.indexes||[],softDelete:e.softDelete||!1,timestamps:e.timestamps!==!1});try{if(this.db&&!this.db.objectStoreNames.contains(t)){if(this._pendingUpgrade&&(await this._pendingUpgrade,this.db.objectStoreNames.contains(t)))return this;this._pendingUpgrade=(async()=>{this.db.close(),this.version=(this.db.version||1)+1,await this.init(),this._pendingUpgrade=null})(),await this._pendingUpgrade}}catch(s){console.error("Erro ao criar store automaticamente:",s)}return this}migration(t){return this._migrations.push(t),this}async init(){return new Promise((t,e)=>{const s=()=>{const o=indexedDB.open(this.dbName,this.version);o.onerror=()=>{const r=o.error;if(r&&(r.name==="VersionError"||/less than the existing version/i.test(String(r.message)))){const i=indexedDB.open(this.dbName);i.onsuccess=()=>{try{const n=i.result.version||1;i.result.close(),this.version=n+1,s()}catch(n){e(new Error(`Erro ao recuperar versÃ£o atual do DB: ${n}`))}},i.onerror=()=>{e(new Error(`Erro ao recuperar versÃ£o atual do DB: ${i.error}`))};return}e(new Error(`Erro ao abrir IndexedDB: ${r}`))},o.onsuccess=()=>{this.db=o.result;const r=this.validateSchema();r.length>0&&console.warn(`âš ï¸ Tabelas faltando no IndexedDB: ${r.join(", ")}`),console.log(`ðŸ’¾ IndexedDB "${this.dbName}" conectado`),t(this)},o.onupgradeneeded=r=>{const i=r.target.result;this._stores.forEach((c,l)=>{let h;i.objectStoreNames.contains(l)?h=r.currentTarget.transaction.objectStore(l):(h=i.createObjectStore(l,{keyPath:c.keyPath,autoIncrement:c.autoIncrement}),console.log(`ðŸ“¦ Tabela criada: ${l}`)),c.indexes.forEach(d=>{const f=typeof d=="string"?d:d.name,w=typeof d=="string"?d:d.keyPath||d.name;if(!h.indexNames.contains(f)){const y=typeof d=="object"?{unique:d.unique||!1,multiEntry:d.multiEntry||!1}:{};h.createIndex(f,w,y)}}),c.timestamps&&(h.indexNames.contains("createdAt")||h.createIndex("createdAt","createdAt",{unique:!1}),h.indexNames.contains("updatedAt")||h.createIndex("updatedAt","updatedAt",{unique:!1})),c.softDelete&&(h.indexNames.contains("deletedAt")||h.createIndex("deletedAt","deletedAt",{unique:!1}))}),["_settings","_queue","_cache"].forEach(c=>{i.objectStoreNames.contains(c)||i.createObjectStore(c,{keyPath:"id",autoIncrement:!0})}),this._migrations.forEach(c=>{try{c(i,r)}catch(l){console.error("Erro na migraÃ§Ã£o:",l)}})}};s()})}table(t){const e=this._stores.get(t)||{};return new m(this,t,e)}validateSchema(){if(!this.db)return[];const t=Array.from(this._stores.keys()),e=Array.from(this.db.objectStoreNames);return t.filter(s=>!e.includes(s))}from(t){return this.table(t)}async transaction(t,e,s){return new Promise((o,r)=>{const i=this.db.transaction(t,e);i.oncomplete=()=>o(),i.onerror=()=>r(i.error),i.onabort=()=>r(new Error("TransaÃ§Ã£o abortada"));try{s(i)}catch(n){i.abort(),r(n)}})}async clear(){const t=Array.from(this.db.objectStoreNames);for(const e of t)await this.table(e).truncate()}async delete(){return this.db.close(),new Promise((t,e)=>{const s=indexedDB.deleteDatabase(this.dbName);s.onsuccess=()=>t(),s.onerror=()=>e(s.error)})}async export(){const t={},e=Array.from(this.db.objectStoreNames);for(const s of e)t[s]=await this.table(s).all();return JSON.stringify(t,null,2)}async import(t){const e=JSON.parse(t);for(const[s,o]of Object.entries(e))if(this.db.objectStoreNames.contains(s)){await this.table(s).truncate();for(const r of o)await this.table(s).insert(r)}}}class m{constructor(t,e,s={}){this.orm=t,this.db=t.db,this.storeName=e,this.config=s,this._where=null,this._orderBy=null,this._orderDir="asc",this._limit=null,this._offset=0,this._withTrashed=!1,this._onlyTrashed=!1}withTrashed(){return this._withTrashed=!0,this}onlyTrashed(){return this._onlyTrashed=!0,this._withTrashed=!0,this}where(t,e){return typeof t=="function"?this._where=t:this._where=s=>s[t]===e,this}whereIn(t,e){return this._where=s=>e.includes(s[t]),this}whereNot(t,e){return this._where=s=>s[t]!==e,this}whereBetween(t,e,s){return this._where=o=>o[t]>=e&&o[t]<=s,this}whereNull(t){return this._where=e=>e[t]===null||e[t]===void 0,this}whereNotNull(t){return this._where=e=>e[t]!==null&&e[t]!==void 0,this}latest(t="createdAt"){return this.orderBy(t,"desc")}oldest(t="createdAt"){return this.orderBy(t,"asc")}async search(t,e=[]){const s=await this.all(),o=t.toLowerCase();return s.filter(r=>e.some(i=>String(r[i]||"").toLowerCase().includes(o)))}async pluck(t){return(await this.all()).map(s=>s[t])}async last(){const t=await this.all();return t[t.length-1]||null}async random(){const t=await this.all();return t.length===0?null:t[Math.floor(Math.random()*t.length)]}async sum(t){return(await this.all()).reduce((s,o)=>s+(Number(o[t])||0),0)}async avg(t){const e=await this.all();return e.length===0?0:await this.sum(t)/e.length}async min(t){const e=await this.all();return e.length===0?null:Math.min(...e.map(s=>Number(s[t])||0))}async max(t){const e=await this.all();return e.length===0?null:Math.max(...e.map(s=>Number(s[t])||0))}orderBy(t,e="asc"){return this._orderBy=t,this._orderDir=e,this}limit(t){return this._limit=t,this}offset(t){return this._offset=t,this}async all(){return new Promise((t,e)=>{const r=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName).getAll();r.onsuccess=()=>{let i=r.result||[];if(this.config.softDelete&&!this._withTrashed?i=i.filter(n=>!n.deletedAt):this.config.softDelete&&this._onlyTrashed&&(i=i.filter(n=>!!n.deletedAt)),this._where&&(i=i.filter(this._where)),this._orderBy&&i.sort((n,c)=>{const l=n[this._orderBy],h=c[this._orderBy];return l<h?this._orderDir==="asc"?-1:1:l>h?this._orderDir==="asc"?1:-1:0}),this._offset>0||this._limit!==null){const n=this._limit!==null?this._offset+this._limit:void 0;i=i.slice(this._offset,n)}t(i)},r.onerror=()=>e(r.error)})}async first(){return this._limit=1,(await this.all())[0]||null}async find(t){return new Promise((e,s)=>{const i=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName).get(t);i.onsuccess=()=>{const n=i.result||null;if(n&&this.config.softDelete&&!this._withTrashed&&n.deletedAt)return e(null);e(n)},i.onerror=()=>s(i.error)})}async count(){return this._where?(await this.all()).length:new Promise((t,e)=>{const r=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName).count();r.onsuccess=()=>t(r.result),r.onerror=()=>e(r.error)})}async exists(t){return await this.find(t)!==null}async insert(t){return new Promise((e,s)=>{const r=this.db.transaction(this.storeName,"readwrite").objectStore(this.storeName),i={...t,createdAt:t.createdAt||new Date().toISOString(),updatedAt:new Date().toISOString()},n=r.add(i);n.onsuccess=()=>{i.id=n.result,this.orm._notify(this.storeName,"insert",i),e(i)},n.onerror=()=>s(n.error)})}async insertMany(t){const e=[];for(const s of t){const o=await this.insert(s);e.push(o)}return e}async update(t,e){return new Promise(async(s,o)=>{const r=await this.find(t);if(!r){o(new Error(`Registro nÃ£o encontrado: ${t}`));return}const n=this.db.transaction(this.storeName,"readwrite").objectStore(this.storeName),c={...r,...e,id:t,updatedAt:new Date().toISOString()},l=n.put(c);l.onsuccess=()=>{this.orm._notify(this.storeName,"update",c),s(c)},l.onerror=()=>o(l.error)})}async upsert(t){return t.id&&await this.exists(t.id)?this.update(t.id,t):this.insert(t)}async firstOrCreate(t,e={}){const s=await this.where(o=>Object.entries(t).every(([r,i])=>o[r]===i)).first();return s||this.insert({...t,...e})}async updateOrCreate(t,e={}){const s=await this.where(o=>Object.entries(t).every(([r,i])=>o[r]===i)).first();return s?this.update(s.id,e):this.insert({...t,...e})}async chunk(t,e){let s=1,o=!0;for(;o;){const{data:r,pagination:i}=await this.paginate(s,t);r.length>0&&await e(r,s),o=i.hasMore,s++}}async delete(t){if(this.config.softDelete){const e=await this.update(t,{deletedAt:new Date().toISOString()});return this.orm._notify(this.storeName,"delete",{id:t,soft:!0}),e}return new Promise((e,s)=>{const i=this.db.transaction(this.storeName,"readwrite").objectStore(this.storeName).delete(t);i.onsuccess=()=>{this.orm._notify(this.storeName,"delete",{id:t,soft:!1}),e(!0)},i.onerror=()=>s(i.error)})}async restore(t){return this.config.softDelete?this.update(t,{deletedAt:null}):!1}async forceDelete(t){return new Promise((e,s)=>{const i=this.db.transaction(this.storeName,"readwrite").objectStore(this.storeName).delete(t);i.onsuccess=()=>e(!0),i.onerror=()=>s(i.error)})}async deleteWhere(){if(!this._where)throw new Error("deleteWhere requer uma condiÃ§Ã£o where()");const t=await this.all();for(const e of t)await this.delete(e.id);return t.length}async truncate(){return new Promise((t,e)=>{const r=this.db.transaction(this.storeName,"readwrite").objectStore(this.storeName).clear();r.onsuccess=()=>{this.orm._notify(this.storeName,"truncate",null),t(!0)},r.onerror=()=>e(r.error)})}async findByIndex(t,e){return new Promise((s,o)=>{const c=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName).index(t).getAll(e);c.onsuccess=()=>s(c.result||[]),c.onerror=()=>o(c.error)})}async increment(t,e,s=1){const o=await this.find(t);return o?(o[e]=(o[e]||0)+s,this.update(t,o)):null}async decrement(t,e,s=1){return this.increment(t,e,-s)}async paginate(t=1,e=10){const s=await this.count(),o=Math.ceil(s/e);return this._offset=(t-1)*e,this._limit=e,{data:await this.all(),pagination:{page:t,perPage:e,total:s,totalPages:o,hasMore:t<o}}}}typeof window<"u"&&(window.IndexedDBORM=b,window.QueryBuilder=m);const a={PENDING:"pending",PROCESSING:"processing",COMPLETED:"completed",FAILED:"failed",CANCELLED:"cancelled"};class p{constructor(t){this.db=t,this.storeName="_queue",this.handlers=new Map,this.actions=this.handlers,this.isProcessing=!1,this.retryAttempts=3,this.retryDelay=1e3,this._listeners=new Map}async init(){return console.log("ðŸ“‹ Job Queue inicializada"),await this._cleanupStuckJobs(),typeof window<"u"&&(window.addEventListener("online",()=>{console.log("ðŸŒ ConexÃ£o restaurada. Processando fila..."),this.processNext()}),"serviceWorker"in navigator&&navigator.serviceWorker.addEventListener("message",t=>{t.data&&t.data.type==="SYNC_TRIGGERED"&&(console.log("ðŸ”„ Sync disparado pelo SW"),this.processNext())}),document.addEventListener("visibilitychange",()=>{document.visibilityState==="visible"&&this.processNext()})),setInterval(()=>this.processNext(),3e4),navigator.onLine&&this.processNext(),this}async _cleanupStuckJobs(){const t=await this.processing();for(const e of t)console.warn(`ðŸ“‹ Recuperando job travado: #${e.id}`),await this.db.table(this.storeName).update(e.id,{status:a.PENDING,error:"Interrompido (Browser fechado ou erro fatal)",updatedAt:new Date().toISOString()})}defineAction(t,e){return this.handlers.set(t,e),console.log(`ðŸ“‹ AÃ§Ã£o registrada: ${t}`),this}defineActions(t){return Object.entries(t).forEach(([e,s])=>{this.defineAction(e,s)}),this}register(t,e){return this.defineAction(t,e)}async dispatch(t,e={},s={}){return this.add(t,e,s)}async add(t,e,s={}){if(s.unique){const i=await this.db.table(this.storeName).where(n=>n.type===t&&n.status===a.PENDING).first();if(i&&JSON.stringify(i.data)===JSON.stringify(e))return console.log(`ðŸ“‹ Job duplicado ignorado: ${t}`),i.id}const o={type:t,data:e,status:a.PENDING,attempts:0,maxAttempts:s.maxAttempts||this.retryAttempts,priority:s.priority||0,delay:s.delay||0,timeout:s.timeout||0,deleteOnComplete:s.deleteOnComplete!==!1,createdAt:new Date().toISOString(),scheduledAt:s.delay?new Date(Date.now()+s.delay).toISOString():new Date().toISOString(),error:null,result:null,progress:0},r=await this.db.table(this.storeName).insert(o);return this._emit("job:added",r),console.log(`ðŸ“‹ Job adicionado: ${t} #${r.id}`),navigator.onLine&&!s.delay&&this.processNext(),r.id}async setProgress(t,e){const s=await this.db.table(this.storeName).update(t,{progress:Math.min(100,Math.max(0,e))});return this._emit("job:progress",s),s}async all(){return this.db.table(this.storeName).orderBy("createdAt","desc").all()}async pending(){return this.db.table(this.storeName).where("status",a.PENDING).orderBy("priority","desc").all()}async processing(){return this.db.table(this.storeName).where("status",a.PROCESSING).all()}async completed(){return this.db.table(this.storeName).where("status",a.COMPLETED).orderBy("updatedAt","desc").all()}async failed(){return this.db.table(this.storeName).where("status",a.FAILED).all()}async get(t){return this.db.table(this.storeName).find(t)}async count(t=null){return t?this.db.table(this.storeName).where("status",t).count():this.db.table(this.storeName).count()}async stats(){const t=await this.all();return{total:t.length,pending:t.filter(e=>e.status===a.PENDING).length,processing:t.filter(e=>e.status===a.PROCESSING).length,completed:t.filter(e=>e.status===a.COMPLETED).length,failed:t.filter(e=>e.status===a.FAILED).length,cancelled:t.filter(e=>e.status===a.CANCELLED).length}}async remove(t){const e=await this.get(t);return e?(await this.db.table(this.storeName).delete(t),this._emit("job:removed",e),console.log(`ðŸ“‹ Job removido: #${t}`),!0):!1}async complete(t,e=null,s=!1){const o=await this.db.table(this.storeName).update(t,{status:a.COMPLETED,result:e,completedAt:new Date().toISOString()});return this._emit("job:completed",o),console.log(`âœ… Job completado: #${t}`),s&&await this.remove(t),o}async fail(t,e){const s=await this.get(t);if(!s)return null;const o={error:e,attempts:s.attempts+1};s.attempts+1<s.maxAttempts?(o.status=a.PENDING,o.scheduledAt=new Date(Date.now()+this.retryDelay*(s.attempts+1)).toISOString()):(o.status=a.FAILED,o.failedAt=new Date().toISOString());const r=await this.db.table(this.storeName).update(t,o);return r.status===a.FAILED?(this._emit("job:failed",r),console.error(`âŒ Job falhou: #${t} - ${e}`)):(this._emit("job:retry",r),console.warn(`ðŸ”„ Job serÃ¡ reenviado: #${t} (tentativa ${r.attempts}/${s.maxAttempts})`)),r}async cancel(t){const e=await this.db.table(this.storeName).update(t,{status:a.CANCELLED,cancelledAt:new Date().toISOString()});return this._emit("job:cancelled",e),console.log(`ðŸš« Job cancelado: #${t}`),e}async retry(t){const e=await this.db.table(this.storeName).update(t,{status:a.PENDING,attempts:0,error:null,scheduledAt:new Date().toISOString()});return this._emit("job:retry",e),console.log(`ðŸ”„ Job reagendado: #${t}`),navigator.onLine&&this.processNext(),e}async retryAll(){const t=await this.failed();for(const e of t)await this.retry(e.id);return t.length}async sync(){return console.log("ðŸ“‹ SincronizaÃ§Ã£o manual disparada"),this.processAll()}async processNext(){if(this.isProcessing||!navigator.onLine)return;const t=await this.db.table(this.storeName).where(e=>e.status===a.PENDING&&new Date(e.scheduledAt)<=new Date).orderBy("priority","desc").first();t&&(await this._processJob(t),setTimeout(()=>this.processNext(),100))}async processAll(){if(!navigator.onLine){console.warn("ðŸ“‹ Sem conexÃ£o. Jobs serÃ£o processados quando online.");return}console.log("ðŸ“‹ Processando todos os jobs pendentes...");const t=await this.pending();for(const e of t)await this._processJob(e);return console.log(`ðŸ“‹ ${t.length} jobs processados`),t.length}async process(t){const e=await this.db.table(this.storeName).where(s=>s.type===t&&s.status===a.PENDING).all();for(const s of e)await this._processJob(s);return e.length}async _processJob(t){const e=this.handlers.get(t.type);if(!e){console.error(`âŒ AÃ§Ã£o nÃ£o encontrada: ${t.type}`),await this.fail(t.id,"AÃ§Ã£o nÃ£o encontrada");return}await this.db.table(this.storeName).update(t.id,{status:a.PROCESSING,startedAt:new Date().toISOString()}),this.isProcessing=!0,this._emit("job:processing",t);try{let s;if(t.timeout>0){const o=new Promise((r,i)=>setTimeout(()=>i(new Error("Job Timeout")),t.timeout));s=await Promise.race([e(t.data,t),o])}else s=await e(t.data,t);t.deleteOnComplete?await this.complete(t.id,s,!0):await this.complete(t.id,s,!1)}catch(s){await this.fail(t.id,s.message||String(s))}finally{this.isProcessing=!1}}async clearCompleted(t=0){const e=await this.completed(),s=Date.now()-t;let o=0;for(const r of e)new Date(r.completedAt||r.updatedAt).getTime()<s&&(await this.remove(r.id),o++);return console.log(`ðŸ“‹ ${o} jobs completados removidos`),o}async clear(){await this.db.table(this.storeName).truncate(),console.log("ðŸ“‹ Fila limpa"),this._emit("queue:cleared")}on(t,e){return this._listeners.has(t)||this._listeners.set(t,new Set),this._listeners.get(t).add(e),()=>this.off(t,e)}off(t,e){const s=this._listeners.get(t);s&&s.delete(e)}_emit(t,e){const s=this._listeners.get(t);s&&s.forEach(o=>{try{o(e)}catch(r){console.error("Erro no listener:",r)}}),document.dispatchEvent(new CustomEvent(`spa:${t}`,{detail:e}))}}typeof window<"u"&&(window.JobStatus=a,window.JobQueue=p);export{b as I,p as J};
